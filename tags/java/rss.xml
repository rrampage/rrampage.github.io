<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>java on A Random Walk</title>
    <link>https://rrampage.github.io/tags/java/</link>
    <description>Recent content in java on A Random Walk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 18 Aug 2018 17:52:23 +0000</lastBuildDate><atom:link href="https://rrampage.github.io/tags/java/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithms: Gray Binary Code</title>
      <link>https://rrampage.github.io/2018/08/18/algorithms-gray-binary-code/</link>
      <pubDate>Sat, 18 Aug 2018 17:52:23 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/08/18/algorithms-gray-binary-code/</guid>
      <description>Gray Binary Code - A different way of ordering numbers</description>
      <content:encoded><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gray_code">Gray binary code</a> is a way of expressing binary numbers such that consecutive numbers differ in exactly 1 digit.
For example, in our conventional binary system, the numbers are</p>
<ul>
<li>000</li>
<li>001</li>
<li>010</li>
<li>011</li>
<li>100</li>
<li>101</li>
<li>110</li>
<li>111 and so on</li>
</ul>
<p>In Gray, they are:</p>
<ul>
<li>000</li>
<li>001</li>
<li>011</li>
<li>010</li>
<li>110</li>
<li>111</li>
<li>101</li>
<li>100 and so on</li>
</ul>
<p>In first system, when we go from &lsquo;001&rsquo; to &lsquo;010&rsquo;, there are 2 changes namely the unit&rsquo;s place becomes &lsquo;0&rsquo; from &lsquo;1&rsquo; and the next digit becomes &lsquo;1&rsquo; from &lsquo;0&rsquo;.
But in Gray&rsquo;s system, &lsquo;001&rsquo; becomes &lsquo;011&rsquo; where there is only 1 change (that of 2nd digit).</p>
<p>Gray codes are used in error correction in communication.</p>
<h3 id="generating-gray-codes-of-length-n">Generating Gray codes of length n</h3>
<p>Is there a property we can use for easily generating the Gray codes of a given length? Yes! In our previous example, we generated all the Gray codes for n=3. Ignoring the most significant bit (<strong>MSB</strong>), notice how the 4th and 5th numbers are equal in their first 2 digits, as are the 3rd and 6th, 2nd and 7th and 1st and 8th. The last 4 numbers are <strong>reflection</strong> of the first 4 if we ignore the last digit. But the last digit is 0 for the 1st 4 numbers and 1 for the last 4&hellip; We have a recursive formulation.</p>
<p>R(0) = []
R(n+1) = 0R(n) + 1R&rsquo;(n)   (R&rsquo;(n) = reverse of R(n))
For n=0, we have an empty list.
For n+1, we take R(n), prepend 0 to all elements and to this sequence, we add reverse of R(n) prepended with 1.</p>
<p>This can be succinctly expressed in Python as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gray_code</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">gray_code</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="o">+</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="o">+</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
</span></span></code></pre></div><p>The above function returns in correct order all the 2^n Gray codes of length n.
We had to add a case for <code>n==1</code> because we are treating the numbers as strings so we can prepend &lsquo;0&rsquo; or &lsquo;1&rsquo;. As n=0 is an empty list, we need another case where we first add the strings.</p>
<h3 id="converting-a-binary-number-to-gray-code">Converting a binary number to Gray code</h3>
<p>How do we convert a binary number to Gray code e.g what is Gray code equivalent of 7 (111 in binary)? From our earlier example, it is 100 = 4. So we need a function which takes an integer and returns the equivalent Gray code as integer.</p>
<p>We can use our recursive formulation from earlier to arrive at an algorithm. Let n = 2^a + b. Here, a is the MSB of n. G(n) is the Gray code of n. From our earlier formula, G(n) = 2^a + G(2^a-1-b) .. because of the reflection property. Thus, we know the value of G(n) at ath digit. We can keep iterating to get the other digits of G(n).</p>
<p>Our pseudo-code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bin_to_gray</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">MSB</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Assume MSB function exists. It finds most significant bit of n</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="n">a</span> <span class="o">+</span> <span class="n">bin_to_gray</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span> <span class="k">as</span> <span class="n">l2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># A simple way to find MSB</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">MSB</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">l2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span></code></pre></div><h4 id="an-even-faster-way">An even faster way:</h4>
<p>It turns out that there is an even faster way of getting the nth Gray code from n.
G(n) = n xor n/2</p>
<p>In C, Java or Python, this is expressed as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><h4 id="addendum--generating-all-gray-codes-knuth-style">Addendum : Generating all Gray codes Knuth style!</h4>
<p>The legendary <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">Donald Knuth</a> uses this algorithm to generate all the tuples in his Art of Computer Programming Vol 4A:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">gen_gray_bin_taocp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// parity bit</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">byte</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// each bit is an element in this array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="w"> </span><span class="c1">// Will print the number in reverse order</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">p</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Find min j so that a[j-1] = 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c1">// Termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">1</span><span class="o">-</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">);</span><span class="w"> </span><span class="c1">// We flip the element at j</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>100 Days Of Code</title>
      <link>https://rrampage.github.io/2018/08/13/100-days-of-code/</link>
      <pubDate>Mon, 13 Aug 2018 13:40:27 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/08/13/100-days-of-code/</guid>
      <description>My 100 Days Of Code Challenge</description>
      <content:encoded><![CDATA[<p>I have started the <a href="https://www.100daysofcode.com/">100 days of code challenge</a>.
I intend to use this time to check out new languages and frameworks and solve some fun problems.</p>
<p>I will update this post with my logs.</p>
<p><strong>Aug 13 2018 D0</strong> : Algorithms for calculating number of combinations and generating them in a lexicographical increasing order. <a href="https://dev.to/rrampage/algorithms-generating-combinations-100daysofcode-4o0a">Blog</a></p>
<p><strong>Aug 14 2018 D1</strong> : Working on algorithm for generating all permutations. First I managed to generate all possible <code>r</code> repetitions of <code>n</code> i.e <code>n^r</code>. Next, I read up and wrote code on Heap&rsquo;s algorithm. I am still not sure of the intuition behind the algorithm. Also, it does not generate the permutations in lexicographical increasing order.</p>
<p><strong>Aug 15 2018 D2</strong> : Learned and implemented an algorithm that generates all permutations in a lexicographical order. It is not as efficient as Heap&rsquo;s algorithm.</p>
<p><strong>Aug 16 2018 D3</strong> : Stumbled across the game of <a href="https://www.nytimes.com/crosswords/game/set">Set</a>. Wrote a small python script which generates all solutions of any given game.</p>
<p><strong>Aug 17 2018 D4</strong> : Learning to use <a href="https://pptr.dev/">Puppeteer.js</a> along with <a href="https://cloud.google.com/functions">Google Cloud Functions</a>. This <a href="https://dev.to/_mertsimsek/to-use-google-cloud-function-as-google-chrome-3e7e">dev.to post</a> was very useful in getting me started.</p>
<p><strong>Aug 18 2018 D5</strong> : Read about Gray Codes, an alternative way of ordering binary numbers in TAOCP Vol 4. Wrote <a href="https://dev.to/rrampage/algorithms-gray-binary-code---a-different-way-of-ordering-numbers-14e3">a blog post</a> exploring some of their properties and how to generate them.</p>
<p><strong>Aug 19 2018 D6</strong> : Wrote a script which calculates iterations for <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&rsquo;s Game of Life</a></p>
<p><strong>Aug 20 2018 D7</strong> : Went through some Dynamic programming problems. Staircase problem is a good example of DP.</p>
<p><strong>Aug 21 2018 D8</strong>: More recursion and DP. Towers of Hanoi and Longest unique sub-string problem.</p>
<p><strong>Aug 24 2018 D9</strong>: After 2 days break due to travel, got back to C and linked lists. I am working through <a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">Stanford&rsquo;s Linked List problems</a>.</p>
<p><strong>Aug 25 2018 D10</strong> Working on a Sudoku solver. Made some more progress on the linked list problems from yesterday.</p>
<p><strong>Aug 26 2018 D11</strong> My sudoku solver can solve easy sudokus from <a href="https://www.codewars.com/kata/sudoku-solver/python">Code Wars</a></p>
<p><a href="https://gist.github.com/rrampage/ddc6f6fdaa0911493d2edec5cc303271">Gist</a></p>
<p><strong>Aug 27 2018 D12</strong> Reading up on back-tracking and n-queens problem.</p>
<p><strong>Aug 28 2018 D13</strong> Some fun with numpy and pandas and setting up virtualenvs.</p>
<p><strong>Aug 29 2018 D14</strong> Solved <a href="https://www.codewars.com/kata/compress-slash-encode-a-message-with-rle-run-length-encoding/train/python">Run Length Encoding problem</a> recursively</p>
<p><strong>Aug 30 2018 D15</strong> Data visualization using matplotlib in Python</p>
<p><strong>Aug 31 2018 D16</strong> 1D Cellular Automata in Java</p>
<p><strong>Sep 1 2018 D17</strong> Solved some regex golf problems</p>
<p><strong>Sep 2 2018 D18</strong> Played around with TMDB API using Python</p>
<p><strong>Sep 3 2018 D19</strong> Some interactive graph visualizations using Gephi</p>
<p><strong>Sep 4 2018 D20</strong> Implemented Tries in Java</p>
<p><strong>Sep 5 2018 D21</strong> Codewars kata on displaying a Tic-tac-toe board in C</p>
<p><strong>Sep 6 2018 D22</strong> Dynamic programming - Coin change problem!</p>
<p><strong>Sep 7 2018 D23</strong> Data cleaning using OpenRefine</p>
<p><strong>Sep 8 2018 D24</strong> Using SQLite for importing tabular data</p>
<p><strong>Sep 9 2018 D25</strong> SQLite window functions</p>
<p><strong>Sep 13 2018 D26</strong> After 3 day break because of job interviews and travel, a simple Python problem on moving 0s to the end of list on <a href="https://www.codewars.com/kata/52597aa56021e91c93000cb0">Codewars</a></p>
<p><strong>Sep 14 2018 D27</strong> Full-text search using SQLite (FTS4 and FTS5 engines)</p>
<p><strong>Sep 15 2018 D28</strong> n-Queens in Python using backtracking in just 20 lines! Code here: <a href="https://gist.github.com/rrampage/8f7fb7e0a53b1a5ec0161386ded429cc">gist</a></p>
<p><strong>Sep 16 2018 D29</strong> Playing around with D3.js for data visualization</p>
<p><strong>Sep 17 2018 D30</strong> Creating SVGs of various shapes in HTML. Awesome guide <a href="http://svgpocketguide.com/book/">here</a></p>
<p><strong>Sep 18 2018 D31</strong> Befunge interpreter on <a href="https://www.codewars.com/kata/befunge-interpreter/">Codewars</a></p>
<p><strong>Sep 19 2018 D32</strong> Learned more about JS <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.reduce</a></p>
<p><strong>Sep 20 2018 D33</strong> Learned more about git branching and detaching from HEAD commit</p>
<p><strong>Sep 21 2018 D34</strong> Learned to use <a href="http://www.grymoire.com/Unix/Sed.html">sed</a> <a href="https://likegeeks.com/sed-linux/">effectively</a></p>
<p><strong>Sep 22 2018 D35</strong> <code>os.walk</code> in Python is very nifty for crawling the filesystem!</p>
<p><strong>Sep 23 2018 D36</strong> More d3.js, visualizations using choropleths for maps</p>
<p><strong>Sep 24 2018 D37</strong> Learned how OOM killer works on Linux. Wrote an article <a href="https://dev.to/rrampage/surviving-the-linux-oom-killer-2ki9">here</a></p>
<p>Have started working once again. I am putting this on hiatus till I find more time. Meanwhile, I will continue posting blog posts on my learning.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>JVM Primer Part 2 - Debugging memory issues</title>
      <link>https://rrampage.github.io/2018/05/16/jvm-primer-part-2-debugging-memory-issues/</link>
      <pubDate>Wed, 16 May 2018 11:53:42 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/05/16/jvm-primer-part-2-debugging-memory-issues/</guid>
      <description>JVM Primer - Debugging memory issues</description>
      <content:encoded><![CDATA[<p>This is part 2 of my series on JVM Memory management and debugging.
Read part 1 <a href="https://dev.to/rrampage/a-primer-on-jvm-memory-management-and-troubleshooting---1-12b6">here</a></p>
<p>In this post, we will cover symptoms of memory issues for JVM-based applications, which tools we can use to diagnose them and how we can fix them.</p>
<h2 id="symptoms">Symptoms</h2>
<p>Here are a few symptoms of memory issues:</p>
<ol>
<li>Poor application performance</li>
<li>Abnormal memory usage</li>
<li>OutOfMemory errors (OOME)</li>
</ol>
<h3 id="poor-application-performance">Poor Application Performance</h3>
<ol>
<li>Application not performing to expected level</li>
<li>Long response times</li>
<li>Dropping client requests</li>
<li>Stuck threads</li>
<li>Service unavailability</li>
<li>Large gaps in timestamps in application logs</li>
</ol>
<h3 id="causes-of-memory-problems">Causes of memory problems:</h3>
<ol>
<li>Misconfigured memory
<ul>
<li><strong>Old generation</strong> memory space is sized smaller than live-set of objects. This triggers a major garbage collection (GC), resulting in larger pauses.</li>
<li><strong>Code cache</strong> is smaller than generated compiled code footprint</li>
<li><strong>Young generation</strong> is not sized appropriately leading to premature promotion of objects</li>
<li><strong>PermGen / Metaspace</strong> not sized correctly leading to full GC</li>
</ul>
</li>
<li>Memory leaks - Unintentional retention of objects in memory spaces
<ul>
<li>Unintentional references to set of objects in heap</li>
<li>Not dereferencing classloader instances appropriateky</li>
<li>Not releasing native resources appropriately</li>
</ul>
</li>
<li>Excessive use of <strong>finalizers</strong>
<ul>
<li>Objects with finalizers may delay their own GC</li>
<li>Finalizer thread needs to invoke finalize() method of the instances before reclaiming them</li>
<li>There can only be 1 Finalizer thread. If it does not keep up with rate at which objects become available for finalization, JVM fails with OOME</li>
<li>Pending finalizer objects are essentially accumulated garbage</li>
<li>Finalizers deprecated in Java 9</li>
</ul>
</li>
<li>Explicit GC calls
<ul>
<li><strong><code>System.gc()</code></strong> and diagnostic data collections can cause long pauses</li>
<li><strong><code>-XX:+DisableExplicitGC</code></strong> can disable System.gc() calls</li>
<li><strong><code>-XX:+PrintClassHistogram</code></strong> also calls an explicit GC when receiving <code>kill -3</code> signal</li>
</ul>
</li>
</ol>
<h3 id="outofmemoryerror">OutOfMemoryError</h3>
<ul>
<li>Hierarchy : <code>Throwable</code> -&gt; <code>Error</code> -&gt; <code>VirtualMachineError</code> -&gt; <code>OutOfMemoryError</code> (Unchecked exception)</li>
<li>Thrown when JVM runs out of space in various memory spaces or cannot proceed further with process execution. Some of the possibilities:
<ul>
<li>Heap space full
<ul>
<li>JVM already invoked full GC but could not free up space</li>
<li>Heap may be sized smaller than app footprint or app is unnecessarily holding on to some set of objects in heap</li>
</ul>
</li>
<li>GC overhead limit exceeded
<ul>
<li>Too many GCs with very less space claimed</li>
<li>Application threads not getting any CPU cycles</li>
</ul>
</li>
<li>Requested array size exceeds VM limit</li>
<li>PermGen space / Metaspace / compressed class space
<ul>
<li>Full GC invoked but unable to free space in Metaspace and application is attempting to load more classes</li>
<li>Metaspace by default &ldquo;unlimited&rdquo; but can be controlled by MaxMetaspaceSize. By default, 1 GB reserved for compressed class space</li>
<li>Make sure that -Xnoclassgc is not in use as it prevents unloading of classes</li>
</ul>
</li>
<li>Native memory - out of swap space / stack trace with native method
<ul>
<li>Native space used for Java thread stacks, loaded jars, zips, native libraries, native resources like files; mem allocated from native code</li>
<li>Unable to allocate more native memory or to create new threads or native memory leaks</li>
<li>Running 32 bit JVM on 64 bit machine puts 4 GB limit on process size</li>
<li>Position of Java heap can put a cap on max size of native heap. Can be controlled by option -XX:HeapBaseMinAddress=n to specify address native heap should be based at</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="codecache-warnings">CodeCache warnings</h3>
<ul>
<li>warning message printed by JVM saying CodeCache full, compiler has been disabled.</li>
<li><strong>No OOME when code cache is full</strong></li>
<li>Emergency cleanup undertaken by Sweeper. This may discard compiled code and JIT may need to perform optimizations again</li>
<li>Ensure appropriate size of CC using <strong><code>ReservedCodeCacheSize</code></strong> option</li>
</ul>
<h3 id="direct-buffer-memory">Direct Buffer Memory</h3>
<ul>
<li><strong><code>ByteBuffer.allocateDirect(N)</code></strong> : Direct buffers which are garbage collected using phantom references and a reference queue</li>
<li>Unlimited memory by default but can be controlled by -XX:MaxDirectMemorySize=n</li>
<li>Used by <strong>Java NIO</strong>. Heap ByteBuffer for I/O uses temporary direct ByteBuffer</li>
</ul>
<h2 id="diagnostic-data-data-collection-and-analysis-tools">Diagnostic Data, Data Collection and Analysis Tools</h2>
<h3 id="troubleshooting-memory-leaks">Troubleshooting Memory leaks</h3>
<ol>
<li>
<p><strong>Confirm memory leak</strong></p>
<ul>
<li>Monitor heap usage over time</li>
<li>If full GCs unable to claim space in OldGen, could be config issue</li>
<li>Heap size may be too small -&gt; Increase heap size and monitor! If issue persists, it could be a memory leak</li>
<li><code>-XX:+GCTimeLimit</code> sets upper limit on amount of time GCs can spend in percent of total time, default 98%</li>
<li><code>-XX:+GCHeapFreeLimit</code> sets lower limit on amount of space that should be freed by a GC, represented as % of max heap, default is 2%</li>
<li><code>OutOfMemoryError</code> is thrown after a full GC if previous 5 consecutive GCs were not able to keep the GC cost below <code>GCTimeLimit</code> or free up at least <code>GCHeapFreeLimit</code> space</li>
<li><code>PermGen</code>/<code>Metaspace</code> may be too small if frequent Full GCs do not claim any space</li>
</ul>
</li>
<li>
<p><strong>Diagnostic data and analysis</strong></p>
<ul>
<li><strong>GC logs</strong> are helpful for determining heap requirements, finding out excessive GCs and long GC pauses and in configuration of memory spaces
<ul>
<li>For Java 9+, G1 options are: <code>-Xlog:gc*,gc+phases=debug:file=gc.log . For non G1, -Xlog:gc*:file=gc.log</code>. For older JVMs, <code>-XX:+PrintGCDetails, -XX:+PrintGCTimeStamps, -XX:+PrintGCDateStamps, -Xloggc:gc.log</code></li>
<li>For checking metaspace, <code>-verbose:class</code> or <code>-XX:+TraceClassLoading , -XX:+TraceClassUnloading</code></li>
<li>We can analyse logs through manual inspection, <a href="https://sourceforge.net/projects/gcviewer/">GCViewer</a>, <a href="https://github.com/jewes/gchisto">GCHisto</a>, <a href="http://gceasy.io/">gceasy.io</a></li>
</ul>
</li>
<li><strong>Heap dumps</strong> help determine unexpected memory growth and memory leaks.
<ul>
<li>We can take heap dumps in follwing ways:
<ul>
<li>jcmd pid GC.heap_dump heapdump.dmp</li>
<li>jmap -dump:format=b,file=snapshot.jmap pid</li>
<li>JConsole or Java Mission Control using MBean HotSpotDiagnostic</li>
<li>JVM option heap dump on OOM error : -XX:+HeapDumpOnOutOfMemoryError . Frequent full GCs can delay collection of heap dump and restart of the process</li>
</ul>
</li>
<li><strong>Eclipse Memory Analyzer Tool (MAT)</strong> shows leak suspects, histograms, unreachable objects, duplicate classes, reference chains to GC roots, allows using <a href="https://en.wikipedia.org/wiki/Object_Query_Language">OQL</a> to explore heap dumps.</li>
<li><strong>JOverFlow for JMC</strong> and <strong>Java VisualVM</strong>, <strong>YourKit</strong> (a commercial profiler) can all take heap dumps.</li>
</ul>
</li>
<li><strong>Heap histograms</strong> - quick view of objects in heap
<ul>
<li>Collect using:
<ul>
<li><code>-XX:+PrintClassHistogram</code> and <code>SIGQUIT</code> on Posix and <code>SIGBREAK</code> on Windows</li>
<li><code>jcmd pid GC.class_histogram filename=histo</code></li>
<li><code>jmap -histo pid core_file</code></li>
<li><code>jhsdb jmap</code> (Java 9)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java flight recordings</strong> - unexpected memory growth and memory leaks, GC events
<ul>
<li>Enable Heap Statistics. Can introduce additional performance overhead</li>
<li>To create a flight recording : <code>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=delay=20s,duration=60s,name=Rec,filename=lol.jfr,settings=profile</code></li>
<li><strong>Flight recordings can find out type of leaking objects but you need heap dumps to find out what is causing the objects to leak</strong></li>
</ul>
</li>
<li><strong>Finalizers</strong>
<ul>
<li>Collect data using JConsole, jmap</li>
<li>Analyse using Eclipse MAT / Visual VM using heap dumps</li>
</ul>
</li>
<li>Native Memory
<ul>
<li>Native Memory Tracker output - tracks native memory used internally by JVM, not for external libraries. Start JVM with <strong><code>NativeMemoryTracking</code></strong> option</li>
<li><strong><code>pmap</code></strong>, <strong><code>libumem</code></strong>, <strong><code>valgrind</code></strong>, core files</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>In this series, we have taken a look at how the JVM manages memory and how the garbage collection process works. We have also gone through how to diagnose memory issues, which tools to use to collect and analyze diagnostic information and some JVM options which can affect application performance.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>A Primer on JVM Memory Management and Troubleshooting - 1</title>
      <link>https://rrampage.github.io/2018/05/15/a-primer-on-jvm-memory-management-and-troubleshooting-1/</link>
      <pubDate>Tue, 15 May 2018 14:14:49 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/05/15/a-primer-on-jvm-memory-management-and-troubleshooting-1/</guid>
      <description>This series is a summary of Oracle&amp;rsquo;s JVM troubleshooting course which gives an overview on JVM memory management, Hotspot VM&amp;rsquo;s garbage collection options, various memory errors and how to troubleshoot them.
In this post (part 1), we will have a look at how JVM manages memory and its different garbage collectors.
You can find Part 2 here
JVM Memory Management Overview The JVM provides automatic memory management to free the programmer from manually managing memory. New objects are allocated on heap memory. A root set consists of pointers to external memory, static variables, threads, JNI references and internal JVM structures. Objects directly reachable from the root set must be kept in heap. Objects reachable from any of the reachable objects must also be in heap. This group of objects are the only ones which can be used by a program. The unreachable objects (garbage) are removed using a process called garbage collection (GC). Reachable objects are compacted i.e moved to contiguous space in heap.</description>
      <content:encoded><![CDATA[<p>This series is a summary of Oracle&rsquo;s <a href="https://apexapps.oracle.com/pls/apex/f?p=44785:149:105166169953256::NO:RP,149:P149_EVENT_ID:5552">JVM troubleshooting course</a> which gives an overview on JVM memory management, Hotspot VM&rsquo;s garbage collection options, various memory errors and how to troubleshoot them.</p>
<p>In this post (part 1), we will have a look at how JVM manages memory and its different garbage collectors.</p>
<p>You can find Part 2 <a href="https://dev.to/rrampage/jvm-primer-part-2---debugging-performance-issues-1od">here</a></p>
<h3 id="jvm-memory-management-overview">JVM Memory Management Overview</h3>
<p>The JVM provides automatic memory management to free the programmer from manually managing memory. New objects are allocated on heap memory. A <strong>root set</strong> consists of pointers to external memory, static variables, threads, <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a> references and internal JVM structures. Objects directly reachable from the root set must be kept in heap. Objects reachable from any of the reachable objects must also be in heap. This group of objects are the only ones which can be used by a program. The unreachable objects (garbage) are removed using a process called <strong>garbage collection (GC)</strong>. Reachable objects are <strong>compacted</strong> i.e moved to contiguous space in heap. This is important as otherwise, the heap will become <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">fragmented</a>.</p>
<h3 id="generational-gc-and-memory-spaces-in-hotspot">Generational GC and Memory Spaces in Hotspot</h3>
<p>When the JVM starts, it requests some memory from the OS. This memory is divided into various spaces.</p>
<p><img loading="lazy" src="https://www.ibm.com/support/knowledgecenter/SS3JSW_5.2.0/com.ibm.help.performance_mgmt.doc/SIPM_HotSpotMemory.jpg" alt="Memory spaces in Hotspot"  title="Memory spaces in Hotspot VM"  />

Memory spaces in JVM prior to JDK 8</p>
<ul>
<li>Separate pools hold objects of diff age ranges</li>
<li>JVM&rsquo;s GC is <strong>generational</strong> and is based on the hypothesis that:
<ul>
<li>Most objects die young</li>
<li>Few references from older to younger objects</li>
</ul>
</li>
<li>There are 2 generations of objects:
<ul>
<li>young : small and collected frequently (minor collection). Objects which survive a threshold number of GCs move to old generation.</li>
<li>old : large, collected infrequently (major collection = Full GC)</li>
</ul>
</li>
<li>Prior to JDK 8, there was also a <strong>permanent generation</strong> which was for storing class representations and metadata, interned strings and class statics. This was replaced by meta-space in JDK 8 and later.</li>
<li><strong>Meta-space</strong> is allocated in native memory. It is managed through JVM options <strong>MetaspaceSize</strong> for initial size and <strong>MaxMetaspaceSize</strong> for maximum.
<ul>
<li>If <strong>UseCompressedClassPointers</strong> is enabled, 2 areas of memory are used for storing classes and their metadata - <strong>meta-space</strong> and <strong>compressed class space</strong>. 64 bit class pointers represented with 32 bit offsets to save space. Class metadata is referenced by 32 bit offsets stored in compressed class space. By default, compressed class space is 1 GB.</li>
</ul>
</li>
<li>Code cache is used to store compiled code generated by JIT (Just in time optimizer), allocated out of native memory and managed by Code Cache Sweeper</li>
</ul>
<h3 id="garbage-collectors-in-hotspot-jvm">Garbage Collectors in Hotspot JVM</h3>
<p>The JVM has different garbage collection methods for different generations of objects. Some of them are described below:</p>
<ul>
<li>Young generation collection
<ul>
<li>Serial - Stop-the-world (STW), copying collector, single threaded</li>
<li>ParNew - STW, copying collector, multiple GC threads</li>
<li>Parallel Scavenge - STW, copying collector, multiple GC threads</li>
</ul>
</li>
<li>Old generation collection
<ul>
<li>Serial Old - STW, mark-sweep-compact collector, single threaded</li>
<li>CMS - Mostly concurrent, low pause</li>
<li>Parallel Old - compacting collector, multiple GC threads</li>
</ul>
</li>
<li>G1 : designed for large heaps and offers predictable short pauses.
<ul>
<li>Has different memory layout for generations</li>
<li>Same collector for all generations</li>
</ul>
</li>
</ul>
<h3 id="gc-options-for-jdk">GC options for JDK</h3>
<p>These are the option flags passed to JVM for specifying which GC to use:</p>
<ul>
<li>UseSerialGC : Serial + SerialOld</li>
<li>UseParNewGC : ParNew + SerialOld . In JDK 9, uses CMS for old gen</li>
<li>UseConcMarkSweepGC : ParNew + CMS + SerialOld
<ul>
<li>CMS used most of time to collect old generation. SerialOld used when concurrent mode failure occurs.</li>
<li>CMS performs most work in concurrent with application threads.</li>
<li>No heap compaction leads to fragmentation. Has floating garbage and requires larger heap sizes.</li>
<li>Free space maintained as linked lists. Allocation expensive compared to bump-the-pointer allocations.</li>
<li>Additional overhead on young collections</li>
<li>Deprecated in JDK 9</li>
</ul>
</li>
<li>UseParallelGC : Parallel Scavenge + Parallel Old.
<ul>
<li>Maximizes throughput.</li>
<li>Default GC till JDK 9</li>
</ul>
</li>
<li>UseG1GC - G1 for both generations
<ul>
<li>Server style GC for multi-core machines with large memory</li>
<li>Low GC pauses with high probability while trying for high throughput</li>
<li>Compacting collector. Low pauses without fragmentation</li>
<li>Better GC ergonomics. Parallel threads and some tasks are concurrent with application threads</li>
<li>Available since JDK 7u4 and default in JDK 9</li>
</ul>
</li>
</ul>
<p>For more detailed information on tuning the garbage collector, read the official <a href="https://docs.oracle.com/javase/9/gctuning/toc.htm">GC Tuning Guide</a></p>
<h4 id="minor-gc-or-how-young-generation-is-collected">Minor GC or How young generation is collected:</h4>
<ol>
<li>When Eden space in young gen is full, reachable objects are marked and moved to the ToSurvivorSpace</li>
<li>Objects in FromSurvivor space that are reachable are moved to ToSurvivorSpace</li>
<li>Objects in FromSurvivor space that have crossed the threshold are promoted to the old generation</li>
<li>Eden becomes empty and is ready for new allocations</li>
<li>To and From Survivor Spaces are switched</li>
</ol>
<h4 id="notes-on-mark-sweep-compact-collector-serial-old">Notes on Mark-Sweep-Compact collector (Serial Old):</h4>
<ul>
<li>Mark phase : marks all live objects</li>
<li>Sweep phase : sweeps over heap identifying garbage</li>
<li>Slide phase : GC performs a sliding compaction by sliding live objects to the start of the heap</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
