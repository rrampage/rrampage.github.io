<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithms on A Random Walk</title>
    <link>https://rrampage.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on A Random Walk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 18 Aug 2018 17:52:23 +0000</lastBuildDate><atom:link href="https://rrampage.github.io/tags/algorithms/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithms: Gray Binary Code</title>
      <link>https://rrampage.github.io/2018/08/18/algorithms-gray-binary-code/</link>
      <pubDate>Sat, 18 Aug 2018 17:52:23 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/08/18/algorithms-gray-binary-code/</guid>
      <description>Gray Binary Code - A different way of ordering numbers</description>
      <content:encoded><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gray_code">Gray binary code</a> is a way of expressing binary numbers such that consecutive numbers differ in exactly 1 digit.
For example, in our conventional binary system, the numbers are</p>
<ul>
<li>000</li>
<li>001</li>
<li>010</li>
<li>011</li>
<li>100</li>
<li>101</li>
<li>110</li>
<li>111 and so on</li>
</ul>
<p>In Gray, they are:</p>
<ul>
<li>000</li>
<li>001</li>
<li>011</li>
<li>010</li>
<li>110</li>
<li>111</li>
<li>101</li>
<li>100 and so on</li>
</ul>
<p>In first system, when we go from &lsquo;001&rsquo; to &lsquo;010&rsquo;, there are 2 changes namely the unit&rsquo;s place becomes &lsquo;0&rsquo; from &lsquo;1&rsquo; and the next digit becomes &lsquo;1&rsquo; from &lsquo;0&rsquo;.
But in Gray&rsquo;s system, &lsquo;001&rsquo; becomes &lsquo;011&rsquo; where there is only 1 change (that of 2nd digit).</p>
<p>Gray codes are used in error correction in communication.</p>
<h3 id="generating-gray-codes-of-length-n">Generating Gray codes of length n</h3>
<p>Is there a property we can use for easily generating the Gray codes of a given length? Yes! In our previous example, we generated all the Gray codes for n=3. Ignoring the most significant bit (<strong>MSB</strong>), notice how the 4th and 5th numbers are equal in their first 2 digits, as are the 3rd and 6th, 2nd and 7th and 1st and 8th. The last 4 numbers are <strong>reflection</strong> of the first 4 if we ignore the last digit. But the last digit is 0 for the 1st 4 numbers and 1 for the last 4&hellip; We have a recursive formulation.</p>
<p>R(0) = []
R(n+1) = 0R(n) + 1R&rsquo;(n)   (R&rsquo;(n) = reverse of R(n))
For n=0, we have an empty list.
For n+1, we take R(n), prepend 0 to all elements and to this sequence, we add reverse of R(n) prepended with 1.</p>
<p>This can be succinctly expressed in Python as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gray_code</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">gray_code</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="o">+</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="o">+</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
</span></span></code></pre></div><p>The above function returns in correct order all the 2^n Gray codes of length n.
We had to add a case for <code>n==1</code> because we are treating the numbers as strings so we can prepend &lsquo;0&rsquo; or &lsquo;1&rsquo;. As n=0 is an empty list, we need another case where we first add the strings.</p>
<h3 id="converting-a-binary-number-to-gray-code">Converting a binary number to Gray code</h3>
<p>How do we convert a binary number to Gray code e.g what is Gray code equivalent of 7 (111 in binary)? From our earlier example, it is 100 = 4. So we need a function which takes an integer and returns the equivalent Gray code as integer.</p>
<p>We can use our recursive formulation from earlier to arrive at an algorithm. Let n = 2^a + b. Here, a is the MSB of n. G(n) is the Gray code of n. From our earlier formula, G(n) = 2^a + G(2^a-1-b) .. because of the reflection property. Thus, we know the value of G(n) at ath digit. We can keep iterating to get the other digits of G(n).</p>
<p>Our pseudo-code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bin_to_gray</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">MSB</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Assume MSB function exists. It finds most significant bit of n</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="n">a</span> <span class="o">+</span> <span class="n">bin_to_gray</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span> <span class="k">as</span> <span class="n">l2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># A simple way to find MSB</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">MSB</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">l2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span></code></pre></div><h4 id="an-even-faster-way">An even faster way:</h4>
<p>It turns out that there is an even faster way of getting the nth Gray code from n.
G(n) = n xor n/2</p>
<p>In C, Java or Python, this is expressed as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><h4 id="addendum--generating-all-gray-codes-knuth-style">Addendum : Generating all Gray codes Knuth style!</h4>
<p>The legendary <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">Donald Knuth</a> uses this algorithm to generate all the tuples in his Art of Computer Programming Vol 4A:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">gen_gray_bin_taocp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// parity bit</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">byte</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// each bit is an element in this array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="w"> </span><span class="c1">// Will print the number in reverse order</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">p</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Find min j so that a[j-1] = 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c1">// Termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">1</span><span class="o">-</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">);</span><span class="w"> </span><span class="c1">// We flip the element at j</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>100 Days Of Code</title>
      <link>https://rrampage.github.io/2018/08/13/100-days-of-code/</link>
      <pubDate>Mon, 13 Aug 2018 13:40:27 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/08/13/100-days-of-code/</guid>
      <description>My 100 Days Of Code Challenge</description>
      <content:encoded><![CDATA[<p>I have started the <a href="https://www.100daysofcode.com/">100 days of code challenge</a>.
I intend to use this time to check out new languages and frameworks and solve some fun problems.</p>
<p>I will update this post with my logs.</p>
<p><strong>Aug 13 2018 D0</strong> : Algorithms for calculating number of combinations and generating them in a lexicographical increasing order. <a href="https://dev.to/rrampage/algorithms-generating-combinations-100daysofcode-4o0a">Blog</a></p>
<p><strong>Aug 14 2018 D1</strong> : Working on algorithm for generating all permutations. First I managed to generate all possible <code>r</code> repetitions of <code>n</code> i.e <code>n^r</code>. Next, I read up and wrote code on Heap&rsquo;s algorithm. I am still not sure of the intuition behind the algorithm. Also, it does not generate the permutations in lexicographical increasing order.</p>
<p><strong>Aug 15 2018 D2</strong> : Learned and implemented an algorithm that generates all permutations in a lexicographical order. It is not as efficient as Heap&rsquo;s algorithm.</p>
<p><strong>Aug 16 2018 D3</strong> : Stumbled across the game of <a href="https://www.nytimes.com/crosswords/game/set">Set</a>. Wrote a small python script which generates all solutions of any given game.</p>
<p><strong>Aug 17 2018 D4</strong> : Learning to use <a href="https://pptr.dev/">Puppeteer.js</a> along with <a href="https://cloud.google.com/functions">Google Cloud Functions</a>. This <a href="https://dev.to/_mertsimsek/to-use-google-cloud-function-as-google-chrome-3e7e">dev.to post</a> was very useful in getting me started.</p>
<p><strong>Aug 18 2018 D5</strong> : Read about Gray Codes, an alternative way of ordering binary numbers in TAOCP Vol 4. Wrote <a href="https://dev.to/rrampage/algorithms-gray-binary-code---a-different-way-of-ordering-numbers-14e3">a blog post</a> exploring some of their properties and how to generate them.</p>
<p><strong>Aug 19 2018 D6</strong> : Wrote a script which calculates iterations for <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&rsquo;s Game of Life</a></p>
<p><strong>Aug 20 2018 D7</strong> : Went through some Dynamic programming problems. Staircase problem is a good example of DP.</p>
<p><strong>Aug 21 2018 D8</strong>: More recursion and DP. Towers of Hanoi and Longest unique sub-string problem.</p>
<p><strong>Aug 24 2018 D9</strong>: After 2 days break due to travel, got back to C and linked lists. I am working through <a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">Stanford&rsquo;s Linked List problems</a>.</p>
<p><strong>Aug 25 2018 D10</strong> Working on a Sudoku solver. Made some more progress on the linked list problems from yesterday.</p>
<p><strong>Aug 26 2018 D11</strong> My sudoku solver can solve easy sudokus from <a href="https://www.codewars.com/kata/sudoku-solver/python">Code Wars</a></p>
<p><a href="https://gist.github.com/rrampage/ddc6f6fdaa0911493d2edec5cc303271">Gist</a></p>
<p><strong>Aug 27 2018 D12</strong> Reading up on back-tracking and n-queens problem.</p>
<p><strong>Aug 28 2018 D13</strong> Some fun with numpy and pandas and setting up virtualenvs.</p>
<p><strong>Aug 29 2018 D14</strong> Solved <a href="https://www.codewars.com/kata/compress-slash-encode-a-message-with-rle-run-length-encoding/train/python">Run Length Encoding problem</a> recursively</p>
<p><strong>Aug 30 2018 D15</strong> Data visualization using matplotlib in Python</p>
<p><strong>Aug 31 2018 D16</strong> 1D Cellular Automata in Java</p>
<p><strong>Sep 1 2018 D17</strong> Solved some regex golf problems</p>
<p><strong>Sep 2 2018 D18</strong> Played around with TMDB API using Python</p>
<p><strong>Sep 3 2018 D19</strong> Some interactive graph visualizations using Gephi</p>
<p><strong>Sep 4 2018 D20</strong> Implemented Tries in Java</p>
<p><strong>Sep 5 2018 D21</strong> Codewars kata on displaying a Tic-tac-toe board in C</p>
<p><strong>Sep 6 2018 D22</strong> Dynamic programming - Coin change problem!</p>
<p><strong>Sep 7 2018 D23</strong> Data cleaning using OpenRefine</p>
<p><strong>Sep 8 2018 D24</strong> Using SQLite for importing tabular data</p>
<p><strong>Sep 9 2018 D25</strong> SQLite window functions</p>
<p><strong>Sep 13 2018 D26</strong> After 3 day break because of job interviews and travel, a simple Python problem on moving 0s to the end of list on <a href="https://www.codewars.com/kata/52597aa56021e91c93000cb0">Codewars</a></p>
<p><strong>Sep 14 2018 D27</strong> Full-text search using SQLite (FTS4 and FTS5 engines)</p>
<p><strong>Sep 15 2018 D28</strong> n-Queens in Python using backtracking in just 20 lines! Code here: <a href="https://gist.github.com/rrampage/8f7fb7e0a53b1a5ec0161386ded429cc">gist</a></p>
<p><strong>Sep 16 2018 D29</strong> Playing around with D3.js for data visualization</p>
<p><strong>Sep 17 2018 D30</strong> Creating SVGs of various shapes in HTML. Awesome guide <a href="http://svgpocketguide.com/book/">here</a></p>
<p><strong>Sep 18 2018 D31</strong> Befunge interpreter on <a href="https://www.codewars.com/kata/befunge-interpreter/">Codewars</a></p>
<p><strong>Sep 19 2018 D32</strong> Learned more about JS <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.reduce</a></p>
<p><strong>Sep 20 2018 D33</strong> Learned more about git branching and detaching from HEAD commit</p>
<p><strong>Sep 21 2018 D34</strong> Learned to use <a href="http://www.grymoire.com/Unix/Sed.html">sed</a> <a href="https://likegeeks.com/sed-linux/">effectively</a></p>
<p><strong>Sep 22 2018 D35</strong> <code>os.walk</code> in Python is very nifty for crawling the filesystem!</p>
<p><strong>Sep 23 2018 D36</strong> More d3.js, visualizations using choropleths for maps</p>
<p><strong>Sep 24 2018 D37</strong> Learned how OOM killer works on Linux. Wrote an article <a href="https://dev.to/rrampage/surviving-the-linux-oom-killer-2ki9">here</a></p>
<p>Have started working once again. I am putting this on hiatus till I find more time. Meanwhile, I will continue posting blog posts on my learning.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Algorithms: Generating Combinations</title>
      <link>https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/</link>
      <pubDate>Sun, 12 Aug 2018 20:20:11 +0000</pubDate>
      
      <guid>https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/</guid>
      <description>Generate combinations of n numbers taken r at a time</description>
      <content:encoded><![CDATA[<p>In how many different ways can we select <code>r</code> objects from a collection of <code>n</code> objects? In mathematics, this is called <a href="https://en.wikipedia.org/wiki/Combination">combinations</a>.</p>
<p><img loading="lazy" src="https://thepracticaldev.s3.amazonaws.com/i/w8utl55xbryxdvolbkdx.jpg" alt="Combinations of 5 objects, taken 2 at a time"  />
</p>
<p>The formula for the number of combinations is:
<img loading="lazy" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/813f7124a61dac205542db3f8491b36cb306453a" alt=""  />

where, <code>n!</code> denotes the factorial of a number that is the product of all numbers from 1 to n (inclusive).</p>
<h3 id="prelude--a-function-for-calculating-factorial-of-a-number">Prelude : A function for calculating factorial of a number</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="calculating-combinations">Calculating Combinations</h3>
<p>That was simple! Let us now move on to calculating the number of combinations given <code>n</code> and <code>r</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">combinations</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>What does this algorithm do? Recall that we need to find <code>n!/r!(n-r)!</code> which will be of the form <code>n(n-1)...(n-r+1)/1.2...r</code>. Similar to <code>factorial</code>, we initialize the result as <code>1</code> and multiply by <code>n-i</code> and divide by <code>i+1</code>. Will this result in a fractional number? No. This is because first, we multiply by <code>n</code> and divide by <code>1</code>. Next, we multiply by <code>n-1</code> and divide by <code>2</code>. Now, either <code>n</code> or <code>n-1</code> have to be even (as they are consecutive numbers). Similarly, next when we divide by 3, one of <code>n</code>,<code>n-1</code> and <code>n-2</code> must be divisible by 3.</p>
<p>In the above code, we also make use of the mathematical property that <code>combinations(n,r) = combinations(n,n-r)</code>. This way, we can do less number of operations for calculating the combinations.</p>
<h3 id="generating-the-combinations">Generating the combinations</h3>
<p>Counting the number of combinations was not so hard! Now, let&rsquo;s generate all the combinations.</p>
<ul>
<li>Given <code>n</code> and <code>r</code>, we will print out all the combinations.</li>
<li>For the <code>n</code> objects, we will use the numbers from 0 to (n-1).</li>
<li>Additionally, we will generate them in a <strong>lexicographical</strong> order which is math speak for sorted order.</li>
<li>Finally, in a combination containing a and b, if a &lt; b, we will print <code>a b</code> instead of <code>b a</code>. Formally stated, if a[k] and a[k+1] are the kth and (k+1)th elements in a generated combination, a[k] &lt; a[k+1] for all k</li>
</ul>
<p>For example, given n = 4, r = 2, we have:</p>
<pre tabindex="0"><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><p>i.e 6 combinations.</p>
<p>Notice that we have <code>0 1</code> and not <code>1 0</code>. This is because we are generating each combination in lexicographical order and we take the minimum for each combination.</p>
<h4 id="generating-for-a-specific-value-of-r-r--2">Generating for a specific value of <code>r</code> (r = 2)</h4>
<p>If we have a specific value of <code>r</code> say 2, the code will involve 2 <code>for</code> loops like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In the code above, our first loop variable <code>i</code> goes from 0 to n-2 and the next variable <code>j</code> goes from <code>i+1</code> to n-1. Why so? This is because we have a requirement for taking the lexicographical minimum combination, so <code>i &lt; j</code> from our constraints.</p>
<p>If value of <code>r</code> is fixed, we can simply create r <code>for</code> loops. But it is not fixed&hellip;</p>
<h4 id="generalizing">Generalizing!</h4>
<p>Now, let&rsquo;s move on to the main goal - generate combinations of <code>n</code> numbers taken <code>r</code> at a time. <em>This section will be a little verbose as I have outlined how I arrived at the correct code. If you are interested in just the algorithm, feel free to skip to the bottom of the article</em></p>
<p>If we notice our previous code for <code>r = 2</code>, our first combination is always <code>0 1</code> as <code>i = 0, j = 1</code>. Similarly, if <code>r</code> was 3, our first combination would be <code>0 1 2</code>. There is a pattern!</p>
<p><strong>By creating an array <code>a</code> of size <code>r</code>, we can generate the first combination as <code>0 1 2 .. r-1</code>.</strong> We have the first combination ready. What about the rest? Somehow, if we increment elements in this array, we will generate the combinations&hellip;</p>
<p>Again, looking at the <code>r = 2</code> case, notice that the <strong>last</strong> combination is <code>n-2 n-1</code>. Similarly, for <code>r = 3</code>, it is <code>n-3 n-2 n-1</code>. Thus, for <code>r</code> elements, it will be <code>n-r+1 n-r+2 .. n-1</code>. There is one more insight - <strong>there is exactly one combination which starts with <code>n-r+1</code></strong>. If our array&rsquo;s first element reaches <code>n-r+1</code>, we are done!</p>
<p><strong>We now have a termination condition for our function: <code>a[0] == n-r+1</code></strong></p>
<p>The code we have so far will look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="c1">// Given</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="c1">// Given</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialize array of size r</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialize array with first combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Our termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// DO SOMETHING!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>We have a <code>while</code> loop that checks for termination condition. For the loop to terminate, we need to steadily progress from our first combination to the last combination. As we are generating elements in lexicographical order, the last element of the array must be incremented first. Then the second from last element and so on.</p>
<p>In our earlier example of <code>n = 4, r = 2</code>, we had</p>
<pre tabindex="0"><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><p>After <code>0 3</code>, we get <code>1 2</code>. This means once the <code>r-1</code> element (last element) reaches its maximum, we increment <code>r-2</code> element from 0 to 1 and also reset the value of <code>r-1</code> element to <code>a[r-2]+1</code> as it must always be at least 1 greater than the <code>r-2</code> element (from our constraints). Moving to our pseudo-code, let&rsquo;s add this to the <code>while</code> loop</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable i keeps track of which element in array we are incrementing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Our termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//If a[i] has reached the max allowable value, decrement i and move to next element in array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// pseudo-code to print out the combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// increment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Reset `i+1` element as previous element + 1, according to our constraints</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Once you have reset the i+1 element, it is no longer &lt; n-r+i and hence, we can move it back to old value</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>We have an index variable <code>i</code> which we use to check which is the element in the array to be incremented. In the first <code>if</code> in above code, we check if the <code>a[i]</code> has reached its maximum value of <code>n-r+i</code>. If yes, we decrement <code>i</code> as <code>a[i]</code> can no longer be incremented. Moving out of <code>if</code>, we then print the combination and increment <code>a[i]</code>. Now, if <code>i</code> is no longer <code>r-1</code> i.e it is no longer last element of <code>a</code>, we must reset it to <code>r-1</code> and also set the value of <code>a[r-1]</code> as <code>a[r-2]+1</code>. This works for <code>r=2</code>. Hooray! We have abstracted out the <code>for</code> loop in the earlier section into a <code>while</code> loop with a few conditionals.</p>
<p>But does this work for <code>r &gt; 2</code>? No&hellip; We need a minor change to make it work! Change the <code>if</code> statements inside the loop to <code>while</code> loops and we are done! In case of first loop, we need to find the maximum <code>i</code> which is less than <code>n+r-i</code>. For example <code>n=5, r=3</code> we have:</p>
<pre tabindex="0"><code>0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4
</code></pre><p>As we move from <code>0 3 4</code> to <code>1 2 3</code>, both <code>i = 2</code> (a[2] = 4) and <code>i = 1</code> (a[1] = 3) are at their maximum. We need to move to <code>i = 0</code>. Similarly, the second <code>if</code> must be a <code>while</code> loop because once we have incremented the a[i] for minimum <code>i</code>, we need to reset the outer elements of array to maintain our constraints.</p>
<h3 id="our-final-code">Our final code:</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// initialize first combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Index to keep track of maximum unsaturated element in array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// a[0] can only be n-r+1 exactly once - our termination condition!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// If outer elements are saturated, keep decrementing i till you find unsaturated element</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// pseudo-code to print array as space separated numbers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Reset each outer element to prev element + 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="proof-of-termination">Proof of termination</h4>
<p>Now that we have our algorithm, how can we show that it terminates? In each iteration of our outer while loop, we increment the element of the array with maximum index i which has not reached value <code>n-r+i</code> while maintaining our constraints. <strong>Due to the lexicographical ordering, our previous combination is always lesser than our currently generated combination.</strong> As there are only a finite number of combinations till we reach our &ldquo;last&rdquo; combination, we can say that our algorithm will terminate.</p>
<h3 id="meta">Meta:</h3>
<p>I began my 100 days of code challenge today with this problem. I will create a separate post explaining my motivations and plans.</p>
<p>Regarding this problem statement of generating combinations, I had some trouble initially moving from <code>r=2</code> case to the general one. It took me some time to find the correct termination condition. I am happy that the final algorithm is relatively compact. I also want to do a proof of correctness for this algorithm later.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
