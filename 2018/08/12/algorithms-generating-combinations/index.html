<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algorithms: Generating Combinations | A Random Walk</title>
<meta name="keywords" content="algorithms, math">
<meta name="description" content="Generate combinations of n numbers taken r at a time">
<meta name="author" content="Raunak">
<link rel="canonical" href="https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/">


<link crossorigin="anonymous" href="/assets/css/stylesheet.3583c276be8b676922334220eddb70a58dd857f110640a70a4641bbbc371cae2.css" integrity="sha256-NYPCdr6LZ2kiM0Ig7dtwpY3YV/EQZApwpGQbu8NxyuI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://rrampage.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rrampage.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rrampage.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rrampage.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rrampage.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Algorithms: Generating Combinations" />
<meta property="og:description" content="Generate combinations of n numbers taken r at a time" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-08-12T20:20:11+00:00" />
<meta property="article:modified_time" content="2018-08-12T20:20:11+00:00" /><meta property="og:site_name" content="A Random Walk" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithms: Generating Combinations"/>
<meta name="twitter:description" content="Generate combinations of n numbers taken r at a time"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://rrampage.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Algorithms: Generating Combinations",
      "item": "https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Algorithms: Generating Combinations",
  "name": "Algorithms: Generating Combinations",
  "description": "Generate combinations of n numbers taken r at a time",
  "keywords": [
    "algorithms", "math"
  ],
  "articleBody": "In how many different ways can we select r objects from a collection of n objects? In mathematics, this is called combinations.\nThe formula for the number of combinations is: where, n! denotes the factorial of a number that is the product of all numbers from 1 to n (inclusive).\nPrelude : A function for calculating factorial of a number public static long factorial(int n) { long res = 1L; for (int i = 1; i \u003c= n; i++) { res *= i; } return res; } Calculating Combinations That was simple! Let us now move on to calculating the number of combinations given n and r\npublic static long combinations(int n, int r) { if (r \u003c 0) { return 0; } long res = 1L; if (r \u003e n - r) { r = n - r; } for (int i = 0; i \u003c r; i++) { res *= (n - i); res /= (i + 1); } return res; } What does this algorithm do? Recall that we need to find n!/r!(n-r)! which will be of the form n(n-1)...(n-r+1)/1.2...r. Similar to factorial, we initialize the result as 1 and multiply by n-i and divide by i+1. Will this result in a fractional number? No. This is because first, we multiply by n and divide by 1. Next, we multiply by n-1 and divide by 2. Now, either n or n-1 have to be even (as they are consecutive numbers). Similarly, next when we divide by 3, one of n,n-1 and n-2 must be divisible by 3.\nIn the above code, we also make use of the mathematical property that combinations(n,r) = combinations(n,n-r). This way, we can do less number of operations for calculating the combinations.\nGenerating the combinations Counting the number of combinations was not so hard! Now, let’s generate all the combinations.\nGiven n and r, we will print out all the combinations. For the n objects, we will use the numbers from 0 to (n-1). Additionally, we will generate them in a lexicographical order which is math speak for sorted order. Finally, in a combination containing a and b, if a \u003c b, we will print a b instead of b a. Formally stated, if a[k] and a[k+1] are the kth and (k+1)th elements in a generated combination, a[k] \u003c a[k+1] for all k For example, given n = 4, r = 2, we have:\n0 1 0 2 0 3 1 2 1 3 2 3 i.e 6 combinations.\nNotice that we have 0 1 and not 1 0. This is because we are generating each combination in lexicographical order and we take the minimum for each combination.\nGenerating for a specific value of r (r = 2) If we have a specific value of r say 2, the code will involve 2 for loops like:\nfor (int i = 0; i \u003c n-1; i++) { for (int j = i+1; j \u003c n; j++) { println(i + \" \" + j); } } In the code above, our first loop variable i goes from 0 to n-2 and the next variable j goes from i+1 to n-1. Why so? This is because we have a requirement for taking the lexicographical minimum combination, so i \u003c j from our constraints.\nIf value of r is fixed, we can simply create r for loops. But it is not fixed…\nGeneralizing! Now, let’s move on to the main goal - generate combinations of n numbers taken r at a time. This section will be a little verbose as I have outlined how I arrived at the correct code. If you are interested in just the algorithm, feel free to skip to the bottom of the article\nIf we notice our previous code for r = 2, our first combination is always 0 1 as i = 0, j = 1. Similarly, if r was 3, our first combination would be 0 1 2. There is a pattern!\nBy creating an array a of size r, we can generate the first combination as 0 1 2 .. r-1. We have the first combination ready. What about the rest? Somehow, if we increment elements in this array, we will generate the combinations…\nAgain, looking at the r = 2 case, notice that the last combination is n-2 n-1. Similarly, for r = 3, it is n-3 n-2 n-1. Thus, for r elements, it will be n-r+1 n-r+2 .. n-1. There is one more insight - there is exactly one combination which starts with n-r+1. If our array’s first element reaches n-r+1, we are done!\nWe now have a termination condition for our function: a[0] == n-r+1\nThe code we have so far will look like:\nint n; // Given int r; // Given int[] a = new int[r]; // Initialize array of size r for (int i = 0; i \u003c r; i++) { a[i] = i; // Initialize array with first combination } while (a[0] \u003c n-r+1) { // Our termination condition // DO SOMETHING! } We have a while loop that checks for termination condition. For the loop to terminate, we need to steadily progress from our first combination to the last combination. As we are generating elements in lexicographical order, the last element of the array must be incremented first. Then the second from last element and so on.\nIn our earlier example of n = 4, r = 2, we had\n0 1 0 2 0 3 1 2 1 3 2 3 After 0 3, we get 1 2. This means once the r-1 element (last element) reaches its maximum, we increment r-2 element from 0 to 1 and also reset the value of r-1 element to a[r-2]+1 as it must always be at least 1 greater than the r-2 element (from our constraints). Moving to our pseudo-code, let’s add this to the while loop\nint i = r-1; // variable i keeps track of which element in array we are incrementing while (a[0] \u003c n-r+1) { // Our termination condition if (i \u003e 0 \u0026\u0026 a[i] == n-r+1) { i = i-1; //If a[i] has reached the max allowable value, decrement i and move to next element in array } printArray(a); // pseudo-code to print out the combination a[i] = a[i]+1; // increment if (i \u003c r-1) { a[i+1] = a[i]+1; // Reset `i+1` element as previous element + 1, according to our constraints i = i+1; // Once you have reset the i+1 element, it is no longer \u003c n-r+i and hence, we can move it back to old value } } We have an index variable i which we use to check which is the element in the array to be incremented. In the first if in above code, we check if the a[i] has reached its maximum value of n-r+i. If yes, we decrement i as a[i] can no longer be incremented. Moving out of if, we then print the combination and increment a[i]. Now, if i is no longer r-1 i.e it is no longer last element of a, we must reset it to r-1 and also set the value of a[r-1] as a[r-2]+1. This works for r=2. Hooray! We have abstracted out the for loop in the earlier section into a while loop with a few conditionals.\nBut does this work for r \u003e 2? No… We need a minor change to make it work! Change the if statements inside the loop to while loops and we are done! In case of first loop, we need to find the maximum i which is less than n+r-i. For example n=5, r=3 we have:\n0 1 2 0 1 3 0 1 4 0 2 3 0 2 4 0 3 4 1 2 3 1 2 4 1 3 4 2 3 4 As we move from 0 3 4 to 1 2 3, both i = 2 (a[2] = 4) and i = 1 (a[1] = 3) are at their maximum. We need to move to i = 0. Similarly, the second if must be a while loop because once we have incremented the a[i] for minimum i, we need to reset the outer elements of array to maintain our constraints.\nOur final code: int[] a = new int[r]; // initialize first combination for (int i = 0; i \u003c r; i++) { a[i] = i; } int i = r - 1; // Index to keep track of maximum unsaturated element in array // a[0] can only be n-r+1 exactly once - our termination condition! while (a[0] \u003c n - r + 1) { // If outer elements are saturated, keep decrementing i till you find unsaturated element while (i \u003e 0 \u0026\u0026 a[i] == n - r + i) { i--; } printArray(a); // pseudo-code to print array as space separated numbers a[i]++; // Reset each outer element to prev element + 1 while (i \u003c r - 1) { a[i + 1] = a[i] + 1; i++; } } Proof of termination Now that we have our algorithm, how can we show that it terminates? In each iteration of our outer while loop, we increment the element of the array with maximum index i which has not reached value n-r+i while maintaining our constraints. Due to the lexicographical ordering, our previous combination is always lesser than our currently generated combination. As there are only a finite number of combinations till we reach our “last” combination, we can say that our algorithm will terminate.\nMeta: I began my 100 days of code challenge today with this problem. I will create a separate post explaining my motivations and plans.\nRegarding this problem statement of generating combinations, I had some trouble initially moving from r=2 case to the general one. It took me some time to find the correct termination condition. I am happy that the final algorithm is relatively compact. I also want to do a proof of correctness for this algorithm later.\n",
  "wordCount" : "1668",
  "inLanguage": "en",
  "datePublished": "2018-08-12T20:20:11.98Z",
  "dateModified": "2018-08-12T20:20:11.98Z",
  "author":{
    "@type": "Person",
    "name": "Raunak"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rrampage.github.io/2018/08/12/algorithms-generating-combinations/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "A Random Walk",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rrampage.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rrampage.github.io/" accesskey="h" title="A Random Walk (Alt + H)">A Random Walk</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rrampage.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://rrampage.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://rrampage.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://rrampage.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://rrampage.github.io/atom.xml" title="RSS">
                    <span>RSS</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Algorithms: Generating Combinations
    </h1>
    <div class="post-description">
      Generate combinations of n numbers taken r at a time
    </div>
    <div class="post-meta">August 12 2018   8 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#prelude--a-function-for-calculating-factorial-of-a-number">Prelude : A function for calculating factorial of a number</a></li>
        <li><a href="#calculating-combinations">Calculating Combinations</a></li>
        <li><a href="#generating-the-combinations">Generating the combinations</a></li>
        <li><a href="#our-final-code">Our final code:</a></li>
        <li><a href="#meta">Meta:</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>In how many different ways can we select <code>r</code> objects from a collection of <code>n</code> objects? In mathematics, this is called <a href="https://en.wikipedia.org/wiki/Combination">combinations</a>.</p>
<p><img loading="lazy" src="https://thepracticaldev.s3.amazonaws.com/i/w8utl55xbryxdvolbkdx.jpg" alt="Combinations of 5 objects, taken 2 at a time"  />
</p>
<p>The formula for the number of combinations is:
<img loading="lazy" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/813f7124a61dac205542db3f8491b36cb306453a" alt=""  />

where, <code>n!</code> denotes the factorial of a number that is the product of all numbers from 1 to n (inclusive).</p>
<h3 id="prelude--a-function-for-calculating-factorial-of-a-number">Prelude : A function for calculating factorial of a number<a hidden class="anchor" aria-hidden="true" href="#prelude--a-function-for-calculating-factorial-of-a-number">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="calculating-combinations">Calculating Combinations<a hidden class="anchor" aria-hidden="true" href="#calculating-combinations">#</a></h3>
<p>That was simple! Let us now move on to calculating the number of combinations given <code>n</code> and <code>r</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">combinations</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>What does this algorithm do? Recall that we need to find <code>n!/r!(n-r)!</code> which will be of the form <code>n(n-1)...(n-r+1)/1.2...r</code>. Similar to <code>factorial</code>, we initialize the result as <code>1</code> and multiply by <code>n-i</code> and divide by <code>i+1</code>. Will this result in a fractional number? No. This is because first, we multiply by <code>n</code> and divide by <code>1</code>. Next, we multiply by <code>n-1</code> and divide by <code>2</code>. Now, either <code>n</code> or <code>n-1</code> have to be even (as they are consecutive numbers). Similarly, next when we divide by 3, one of <code>n</code>,<code>n-1</code> and <code>n-2</code> must be divisible by 3.</p>
<p>In the above code, we also make use of the mathematical property that <code>combinations(n,r) = combinations(n,n-r)</code>. This way, we can do less number of operations for calculating the combinations.</p>
<h3 id="generating-the-combinations">Generating the combinations<a hidden class="anchor" aria-hidden="true" href="#generating-the-combinations">#</a></h3>
<p>Counting the number of combinations was not so hard! Now, let&rsquo;s generate all the combinations.</p>
<ul>
<li>Given <code>n</code> and <code>r</code>, we will print out all the combinations.</li>
<li>For the <code>n</code> objects, we will use the numbers from 0 to (n-1).</li>
<li>Additionally, we will generate them in a <strong>lexicographical</strong> order which is math speak for sorted order.</li>
<li>Finally, in a combination containing a and b, if a &lt; b, we will print <code>a b</code> instead of <code>b a</code>. Formally stated, if a[k] and a[k+1] are the kth and (k+1)th elements in a generated combination, a[k] &lt; a[k+1] for all k</li>
</ul>
<p>For example, given n = 4, r = 2, we have:</p>
<pre tabindex="0"><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><p>i.e 6 combinations.</p>
<p>Notice that we have <code>0 1</code> and not <code>1 0</code>. This is because we are generating each combination in lexicographical order and we take the minimum for each combination.</p>
<h4 id="generating-for-a-specific-value-of-r-r--2">Generating for a specific value of <code>r</code> (r = 2)<a hidden class="anchor" aria-hidden="true" href="#generating-for-a-specific-value-of-r-r--2">#</a></h4>
<p>If we have a specific value of <code>r</code> say 2, the code will involve 2 <code>for</code> loops like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In the code above, our first loop variable <code>i</code> goes from 0 to n-2 and the next variable <code>j</code> goes from <code>i+1</code> to n-1. Why so? This is because we have a requirement for taking the lexicographical minimum combination, so <code>i &lt; j</code> from our constraints.</p>
<p>If value of <code>r</code> is fixed, we can simply create r <code>for</code> loops. But it is not fixed&hellip;</p>
<h4 id="generalizing">Generalizing!<a hidden class="anchor" aria-hidden="true" href="#generalizing">#</a></h4>
<p>Now, let&rsquo;s move on to the main goal - generate combinations of <code>n</code> numbers taken <code>r</code> at a time. <em>This section will be a little verbose as I have outlined how I arrived at the correct code. If you are interested in just the algorithm, feel free to skip to the bottom of the article</em></p>
<p>If we notice our previous code for <code>r = 2</code>, our first combination is always <code>0 1</code> as <code>i = 0, j = 1</code>. Similarly, if <code>r</code> was 3, our first combination would be <code>0 1 2</code>. There is a pattern!</p>
<p><strong>By creating an array <code>a</code> of size <code>r</code>, we can generate the first combination as <code>0 1 2 .. r-1</code>.</strong> We have the first combination ready. What about the rest? Somehow, if we increment elements in this array, we will generate the combinations&hellip;</p>
<p>Again, looking at the <code>r = 2</code> case, notice that the <strong>last</strong> combination is <code>n-2 n-1</code>. Similarly, for <code>r = 3</code>, it is <code>n-3 n-2 n-1</code>. Thus, for <code>r</code> elements, it will be <code>n-r+1 n-r+2 .. n-1</code>. There is one more insight - <strong>there is exactly one combination which starts with <code>n-r+1</code></strong>. If our array&rsquo;s first element reaches <code>n-r+1</code>, we are done!</p>
<p><strong>We now have a termination condition for our function: <code>a[0] == n-r+1</code></strong></p>
<p>The code we have so far will look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="c1">// Given</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="c1">// Given</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialize array of size r</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialize array with first combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Our termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// DO SOMETHING!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>We have a <code>while</code> loop that checks for termination condition. For the loop to terminate, we need to steadily progress from our first combination to the last combination. As we are generating elements in lexicographical order, the last element of the array must be incremented first. Then the second from last element and so on.</p>
<p>In our earlier example of <code>n = 4, r = 2</code>, we had</p>
<pre tabindex="0"><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><p>After <code>0 3</code>, we get <code>1 2</code>. This means once the <code>r-1</code> element (last element) reaches its maximum, we increment <code>r-2</code> element from 0 to 1 and also reset the value of <code>r-1</code> element to <code>a[r-2]+1</code> as it must always be at least 1 greater than the <code>r-2</code> element (from our constraints). Moving to our pseudo-code, let&rsquo;s add this to the <code>while</code> loop</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable i keeps track of which element in array we are incrementing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Our termination condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="o">+</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//If a[i] has reached the max allowable value, decrement i and move to next element in array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// pseudo-code to print out the combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// increment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Reset `i+1` element as previous element + 1, according to our constraints</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Once you have reset the i+1 element, it is no longer &lt; n-r+i and hence, we can move it back to old value</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>We have an index variable <code>i</code> which we use to check which is the element in the array to be incremented. In the first <code>if</code> in above code, we check if the <code>a[i]</code> has reached its maximum value of <code>n-r+i</code>. If yes, we decrement <code>i</code> as <code>a[i]</code> can no longer be incremented. Moving out of <code>if</code>, we then print the combination and increment <code>a[i]</code>. Now, if <code>i</code> is no longer <code>r-1</code> i.e it is no longer last element of <code>a</code>, we must reset it to <code>r-1</code> and also set the value of <code>a[r-1]</code> as <code>a[r-2]+1</code>. This works for <code>r=2</code>. Hooray! We have abstracted out the <code>for</code> loop in the earlier section into a <code>while</code> loop with a few conditionals.</p>
<p>But does this work for <code>r &gt; 2</code>? No&hellip; We need a minor change to make it work! Change the <code>if</code> statements inside the loop to <code>while</code> loops and we are done! In case of first loop, we need to find the maximum <code>i</code> which is less than <code>n+r-i</code>. For example <code>n=5, r=3</code> we have:</p>
<pre tabindex="0"><code>0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4
</code></pre><p>As we move from <code>0 3 4</code> to <code>1 2 3</code>, both <code>i = 2</code> (a[2] = 4) and <code>i = 1</code> (a[1] = 3) are at their maximum. We need to move to <code>i = 0</code>. Similarly, the second <code>if</code> must be a <code>while</code> loop because once we have incremented the a[i] for minimum <code>i</code>, we need to reset the outer elements of array to maintain our constraints.</p>
<h3 id="our-final-code">Our final code:<a hidden class="anchor" aria-hidden="true" href="#our-final-code">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// initialize first combination</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Index to keep track of maximum unsaturated element in array</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// a[0] can only be n-r+1 exactly once - our termination condition!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// If outer elements are saturated, keep decrementing i till you find unsaturated element</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// pseudo-code to print array as space separated numbers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Reset each outer element to prev element + 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="proof-of-termination">Proof of termination<a hidden class="anchor" aria-hidden="true" href="#proof-of-termination">#</a></h4>
<p>Now that we have our algorithm, how can we show that it terminates? In each iteration of our outer while loop, we increment the element of the array with maximum index i which has not reached value <code>n-r+i</code> while maintaining our constraints. <strong>Due to the lexicographical ordering, our previous combination is always lesser than our currently generated combination.</strong> As there are only a finite number of combinations till we reach our &ldquo;last&rdquo; combination, we can say that our algorithm will terminate.</p>
<h3 id="meta">Meta:<a hidden class="anchor" aria-hidden="true" href="#meta">#</a></h3>
<p>I began my 100 days of code challenge today with this problem. I will create a separate post explaining my motivations and plans.</p>
<p>Regarding this problem statement of generating combinations, I had some trouble initially moving from <code>r=2</code> case to the general one. It took me some time to find the correct termination condition. I am happy that the final algorithm is relatively compact. I also want to do a proof of correctness for this algorithm later.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://rrampage.github.io/tags/algorithms/">algorithms</a></li>
      <li><a href="https://rrampage.github.io/tags/math/">math</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rrampage.github.io/2018/08/13/100-days-of-code/">
    <span class="title">« Prev</span>
    <br>
    <span>100 Days Of Code</span>
  </a>
  <a class="next" href="https://rrampage.github.io/2018/05/26/awk-a-useful-little-language/">
    <span class="title">Next »</span>
    <br>
    <span>Awk - A useful little language</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rrampage.github.io/">A Random Walk</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
